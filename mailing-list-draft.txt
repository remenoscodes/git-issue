To: git@vger.kernel.org
Subject: [RFC] Distributed Issue Tracking Format using Git Refs and Trailers

Hi Git community,

I am submitting for review a format specification for distributed issue
tracking that uses only Git's existing primitives: commits, refs, and
trailers. This is NOT a proposal to merge a tool into Git -- rather, it
is a request for feedback on a data format that could enable
interoperable issue tracking across Git implementations.

## Background

In 2007, Linus Torvalds proposed "a git for bugs" -- distributed, local,
without requiring a web interface. Nearly two decades later, issues
remain centralized in hosting platforms. Migrating a repository between
platforms (GitHub to GitLab, GitLab to Forgejo, etc.) transfers code but
not issues, which stay trapped in proprietary APIs.

Multiple attempts have been made over the years:
- git-bug (2018): CRDT-based with JSON operations
- git-dit (2016): commit-based with trailers (closest to this proposal)
- git-appraise (2015): Google's refs/notes approach
- Fossil's ticket system (2006): immutable artifacts with SQLite
- git-issue/Spinellis (2017): file-per-field in a branch
- And several others (BE, ticgit, Ditz, SIT)

All of these tools died or remain niche. A key observation: NONE produced
a standalone format specification. Each tool defined its own
incompatible data model. This proposal takes a different approach:
specify the format FIRST, independent of any specific tool.

## The Proposal

The format stores issues as commit chains under the `refs/issues/`
namespace. Each issue is identified by a UUID (refs/issues/<uuid>).
Issue metadata (state, labels, assignee, priority) is stored in Git
trailers. Comments are individual commits in the chain. All commits use
the empty tree (no file content).

Example issue structure:

    refs/issues/a7f3b2c1-4e5d-4a8b-9c1e-2f3a4b5c6d7e
        |
        v
      [commit N]  <-- "Fix deployed, closing" + State: closed trailer
        |
      [commit 2]  <-- "I can reproduce this on Firefox too" (comment)
        |
      [commit 1]  <-- "Fix login crash" + State: open trailer (root)

Key design principles:
1. Git-native: no JSON, no external databases, no custom binary formats
2. Distributed-first: deterministic merge rules for concurrent edits
3. Tooling-friendly: queryable with git for-each-ref and git log
4. Simple over clever: LWW and three-way set merge instead of CRDTs
5. Format over tool: any implementation producing conforming data is valid

The full specification is attached below and is also available at:
https://github.com/remenoscodes/git-issue/blob/main/ISSUE-FORMAT.md

## Production Use

This format has been in production use for approximately one year, from
initial prototype (v0.1) through current release (v1.0.0). The reference
implementation is a POSIX shell tool that has been tested on Linux,
macOS, and BSD. The implementation includes:
- 11 commands (create, list, show, comment, edit, state, import/export)
- 106 tests covering core functionality, edge cases, and GitHub bridge
- Successful round-trip import/export with GitHub Issues

The git-issue project itself uses this format for its own issue tracking
(dogfooding).

## Request for Format Blessing

I am explicitly requesting review and feedback on the FORMAT
SPECIFICATION, not the tool. The goal is to establish `refs/issues/*`
with this trailer-based commit structure as a community-recognized
standard that multiple tools and platforms could adopt.

If this format gains acceptance, potential benefits include:
- Hosting platforms (GitHub, GitLab, Forgejo, Gitea) could add native
  support for displaying and managing refs/issues/*
- Issue data becomes portable across platforms via standard git push/fetch
- Multiple independent implementations could interoperate on the same data
- Issues could travel with code in git bundles, mirrors, and forks

## Relationship to Existing Git Formats

This proposal does NOT modify any existing Git formats or ref namespaces.
It uses:
- Standard Git refs (refs/issues/* is currently unused by Git itself)
- Standard commit objects with the empty tree
- Standard Git trailers (gitformat-trailers)
- Standard transport (git fetch/push)

Compatibility:
- Works with reftable backend (no loose files outside refs)
- Compatible with shallow clones (--depth=1 gives current state)
- Works with protocol v2 (ref filtering reduces advertisement cost)
- Requires Git 2.17+ (for %(trailers:key=...,valueonly) format)

## Comparison to Prior Art

Unlike git-bug's CRDT approach with Lamport clocks, this format uses
simpler heuristics (last-writer-wins for scalar fields, three-way set
merge for labels). Unlike git-appraise's refs/notes approach, this uses
commit chains with proper parent links. Unlike Fossil's artifact system,
this uses Git's native object model instead of SQLite.

The closest prior art is git-dit (2016), which independently arrived at
a similar commit-chain-with-trailers design. git-dit is no longer
maintained, but the convergent design validates the approach.

## Non-Goals (Explicit Limitations)

The format intentionally does NOT address:
- Access control (enforced at repository level, not format level)
- Real-time synchronization (uses standard git push/fetch)
- Non-developer participation (requires Git command-line proficiency)
- Binary attachments (deferred to future format version)
- Platform integration requirements (platforms may adopt optionally)

## Questions for the Community

1. Is the `refs/issues/*` namespace acceptable, or does it conflict with
   any planned Git features?

2. Are there edge cases in the merge rules (Section 6) that would cause
   problems in practice?

3. Should the minimum Git version requirement (2.17, April 2018) be
   raised or lowered?

4. Are there security considerations beyond those in Section 11
   (trailer injection, command injection)?

5. Would the Git project consider including a gitformat-issue(5) man
   page if this format gains adoption, or is the bar for new format
   specs prohibitively high?

## Next Steps

Based on feedback from this RFC, I plan to:
1. Revise the specification to address any concerns raised
2. Convert the spec to AsciiDoc format (gitformat-issue.txt)
3. Seek adoption from at least one hosting platform (currently in
   discussion with Forgejo/Codeberg)
4. Encourage independent implementations to validate interoperability
5. Submit a formal patch series for contrib/git-issue/ if there is
   interest

I welcome all feedback, criticism, and suggestions for improvement.

## Full Specification

[The complete ISSUE-FORMAT.md specification follows, approximately 700
lines. For mailing list submission, I will paste the full text inline
below this cover letter.]

---

Best regards,
Emerson Soares
remenoscodes@gmail.com

P.S. - I have studied the git-dit, git-bug, git-appraise, and Fossil
prior art extensively. I am happy to discuss technical comparisons or
design trade-offs in detail. The prior art analysis is available at:
https://github.com/remenoscodes/git-issue/blob/main/Documentation/reviews/prior-art-analysis.md
