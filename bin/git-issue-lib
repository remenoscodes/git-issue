#!/bin/sh
#
# git-issue-lib - Shared functions for git-issue commands
#
# Source this file from git-issue commands:
#   . "$(dirname "$0")/git-issue-lib"
#

# Resolve a short issue ID to full ref(s)
# Uses git's own ref glob matching for O(1) lookup
resolve_issue() {
	_ri_prefix="$1"
	git for-each-ref --format='%(refname)' "refs/issues/$_ri_prefix*"
}

# Validate that a string contains no newlines
validate_no_newlines() {
	case "$1" in
		*"
"*)
			echo "error: $2 must not contain newlines" >&2
			exit 1
			;;
	esac
}

# Normalize and validate a comma-separated label string
# Args: $1 = raw label string (e.g., "bug, feature, bug")
# Output: normalized string (e.g., "bug, feature") to stdout
# Exits with error if any label contains a comma
normalize_labels() {
	_raw="$1"

	# Empty input is valid (no labels)
	test -z "$_raw" && return 0

	# Save/restore IFS for comma splitting
	_old_ifs="$IFS"
	IFS=','

	_normalized=""
	_seen="" # Track seen labels for deduplication

	for _label in $_raw
	do
		# Trim leading/trailing whitespace
		_label="$(printf '%s' "$_label" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

		# Skip empty labels
		test -z "$_label" && continue

		# Validate: label must not contain comma
		# (This check is on trimmed individual label, not the original input)
		case "$_label" in
			*,*)
				echo "error: label '$_label' contains a comma (use multiple -l flags instead)" >&2
				IFS="$_old_ifs"
				exit 1
				;;
		esac

		# Check if already seen (case-sensitive deduplication per spec 4.7)
		_duplicate=0
		_check_ifs="$IFS"
		IFS=','
		for _seen_label in $_seen
		do
			if test "$_seen_label" = "$_label"
			then
				_duplicate=1
				break
			fi
		done
		IFS="$_check_ifs"

		# Add to result if not duplicate
		if test "$_duplicate" -eq 0
		then
			if test -n "$_normalized"
			then
				_normalized="$_normalized, $_label"
			else
				_normalized="$_label"
			fi

			# Track as seen
			if test -n "$_seen"
			then
				_seen="$_seen,$_label"
			else
				_seen="$_label"
			fi
		fi
	done

	IFS="$_old_ifs"
	printf '%s' "$_normalized"
}

# Get the effective title for an issue ref
# Checks for Title: trailer override, falls back to root commit subject
get_issue_title() {
	_git_ref="$1"
	_title_override="$(git log --format='%(trailers:key=Title,valueonly)' "$_git_ref" | \
		sed '/^$/d' | head -1)"
	_title_override="$(printf '%s' "$_title_override" | sed 's/^[[:space:]]*//')"

	if test -n "$_title_override"
	then
		printf '%s' "$_title_override"
	else
		_root="$(git rev-list --max-parents=0 "$_git_ref")"
		git log -1 --format='%s' "$_root"
	fi
}
